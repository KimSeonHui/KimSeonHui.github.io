1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
5:I[9665,[],"MetadataBoundary"]
7:I[9665,[],"OutletBoundary"]
a:I[4911,[],"AsyncMetadataOutlet"]
c:I[9665,[],"ViewportBoundary"]
e:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/e544322cefe4a38a.css","style"]
0:{"P":null,"b":"U-w4vQKRIXUzI6nHbf9M4","p":"","c":["","posts","mini-react-Day2"],"i":false,"f":[[["",{"children":["posts",{"children":[["id","mini-react-Day2","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e544322cefe4a38a.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["id","mini-react-Day2","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",["$","$L5",null,{"children":"$L6"}],null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","73uansqwknwf1bk1D7kdv",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
f:"$Sreact.suspense"
10:I[4911,[],"AsyncMetadata"]
6:["$","$f",null,{"fallback":null,"children":["$","$L10",null,{"promise":"$@11"}]}]
9:null
12:T3440,<h1>JSX란?</h1>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<p>지금이야 JSX에 익숙하지만, 처음 리액트를 배울 때만해도 도대체 이게 무슨 문법인가하는 생각이 들었다.<br>
JSX에 대해서 공식문서는 이렇게 소개한다.</p>
<blockquote>
<p>JSX는 JavaScript를 확장한 문법으로, JavaScript 파일을 HTML과 비슷하게 마크업을 작성할 수 있도록 해줍니다.
리액트에서는 JSX를 활용해 컴포넌트를 만들고 화면에 어떤 내용을 보여줄 지를 결정한다.</p>
</blockquote>
<p><strong>JSX = Javascript + HTML</strong> 라고 할 수 있을 것 같다</p>
<p>기존의 웹은 HTML, CSS, Javascript의 역할 분담이 확실했다. HTML로는 내용, CSS로는 스타일, Javascript로는 로직을 작성하며 HTML, CSS, Javscript를 각각의 분리된 파일로 관리한다.
하지만 점점 더 웹이 인터랙티브해지면서 로직이 어떤 내용을 보여줄 지 결정하는 경우가 많아졌다.</p>
<p>이런 이유로 리액트에서는 렌더링 로직과 마크업 로직이 함께 JSX라는 문법으로 존재하게 되었다.</p>
<br />
<h1>JSX는 어떻게 HTML로 바뀌는 걸까?</h1>
<p>리액트로 만든 프로젝트를 개발자도구를 켜서 보면 JSX로 만들었지만 일반 html로 만든 것과 동일하게 보인다.
JSX는 브라우저가 직접 이해하지 못하기 때문에 트랜스파일링을 통해 브라우저가 이해할 수 있는 언어로 바꿔주는 작업이 필요하다.</p>
<p>이 부분에 대해 찾아볼 때 트랜스파일링을 하면 Babel과 같은 트랜스파일러에 의해 JSX 코드가 <code>React.createElement</code>로 변환된다.<br>
그리고 <code>React.createElement</code>에 의해 자바스크립트 객체로 최종적으로 바뀐다라고 설명 되어 있는 내용을 많이 봤다.</p>
<p>하지만 <a href="https://ko.react.dev/reference/react/createElement#createelement">리액트 공식 문서</a>를 살펴보면 <code>React.createElement</code>는 <strong>레거시 api</strong>로 소개되어 있다.<br>
오잉? 그렇다면 내가 찾아본 설명이 옛날 거고 지금은 내부 로직이 바뀐건가? 왜 <code>createElement</code>가 레거시 api로 되어 있지 싶어서 더 찾아봤다.</p>
<br />
<h2>createElement가 레거시 api가 된 이유</h2>
<p>2019년에 <code>createElement</code>에 대한 <a href="https://github.com/reactjs/rfcs/blob/c71cb88b0badbe9119e1399688ee481e62da142b/text/0000-create-element-changes.md">RFC</a>가 올라왔다.</p>
<blockquote>
<p><strong>RFC란?</strong><br>
"Request for Comments"의 약자로, 기술적인 제안이나 표준을 문서화하는 방식으로, 오픈소스에서 새로운 기능이나 변경사항을 제안하고
논의하기 위한 문서 같은 의미로 사용됨</p>
</blockquote>
<p>RFC에서 말하는 createElement의 문제점을 정리하면 이렇다</p>
<ul>
<li>트랜스파일링 된 createElement를 호출하기 위헤 불필요한 <code>import React from 'react'</code> 구문이 항상 필요함</li>
<li>클래스 컴포넌트를 사용할 때는 의미가 있었지만 함수형 컴포넌트로 바뀌면서 의미가 없어진 기능들이 존재</li>
<li>createElement는 JSX의 사용을 생각하고 만든 것이 아니라 JSX 사용 없이 수동으로 작성할 수 있도록 한 것</li>
</ul>
<p>이러한 문제로 인해 <strong>함수형 컴포넌트</strong> + <strong>JSX</strong> 상황에 맞게 createElement 개선하는 작업이 진행되었다.<br>
createElement 대한 더 자세한 내용은 RFC에서 확인할 수 있다.</p>
<br />
<h2>개선된 JSX 트랜스파일링</h2>
<p>리액트 17 버전 부터는 트랜스파일링 결과가 <code>createElement</code>가 아니라 <code>jsx</code>로 바뀐다.</p>
<p>jsx에 대한 내부 코드를 살펴보자.<br>
jsx 함수는 dev, prod 환경에 따라 다른 함수를 사용한다. 운영 환경에서 사용되는 jsxProd만 살펴볼 예정이다.</p>
<p>코드를 처음 살펴보면서 공부하는 거라 어렵게 느껴지고 코드에 압도(?) 당하는 거 같지만 차근 차근 살펴보면 jsx 함수는 props, key를 설정하는 함수라는 걸 알 수 있다.</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">jsxProd</span>(<span class="hljs-params">type, config, maybeKey</span>) {
  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// key 설정</span>
  <span class="hljs-keyword">if</span> (maybeKey !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-comment">// ...</span>
    key = <span class="hljs-string">&quot;&quot;</span> + maybeKey;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidKey</span>(config)) {
    <span class="hljs-comment">// ...</span>
    key = <span class="hljs-string">&quot;&quot;</span> + config.<span class="hljs-property">key</span>;
  }

  <span class="hljs-comment">// props 설정</span>
  <span class="hljs-keyword">let</span> props;
  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&quot;key&quot;</span> <span class="hljs-keyword">in</span> config)) {
    props = config;
  } <span class="hljs-keyword">else</span> {
    props = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> config) {
      <span class="hljs-comment">// Skip over reserved prop names</span>
      <span class="hljs-keyword">if</span> (propName !== <span class="hljs-string">&quot;key&quot;</span>) {
        props[propName] = config[propName];
      }
    }
  }

  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// ReactElement 반환</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactElement</span>(
    type,
    key,
    <span class="hljs-literal">undefined</span>,
    <span class="hljs-literal">undefined</span>,
    <span class="hljs-title function_">getOwner</span>(),
    props,
    <span class="hljs-literal">undefined</span>,
    <span class="hljs-literal">undefined</span>
  );
}
</code></pre>
<p>spread 구문으로 key 가 props로 전달되는 게 가능하지만 점차 deprecated할 예정인데,<br>
이를 점진적으로 개선하기 위해 maybeKey를 사용해 props로 전달된 key와 명시적으로 전달된 key를 구분한다.</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (maybeKey !== <span class="hljs-literal">undefined</span>) {
  <span class="hljs-comment">// ...</span>
  key = <span class="hljs-string">&quot;&quot;</span> + maybeKey;
}

<span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidKey</span>(config)) {
  <span class="hljs-comment">// ...</span>
  key = <span class="hljs-string">&quot;&quot;</span> + config.<span class="hljs-property">key</span>;
}
</code></pre>
<p>jsx 함수에 대해 살펴 봤으니 그 다음으로는 jsx가 반환하는 ReactElement를 살펴보고자 한다.</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactElement</span>(<span class="hljs-params">
  type,
  key,
  self,
  source,
  owner,
  props,
  debugStack,
  debugTask
</span>) {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">let</span> element;

  <span class="hljs-comment">// ...</span>
  element = {
    <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span>,
    type,
    key,
    ref,
    props,
  };

  <span class="hljs-keyword">return</span> element;
}
</code></pre>
<p>ReactElement 함수에 다른 내용도 있지만 간단히 정리하면 위와 같이 element 객체를 정의하고 그 객체를 반환하는 함수이다.
따라서, createElement에서 jsx로 코드가 바뀌었지만 동일하게 자바스크립트 객체로 최종적으로 반환한다.</p>
<pre><code class="language-javascript hljs"><span class="hljs-comment">// 이런 JSX 문법이</span>
<span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-comment">// 이런 _jsx 호출로 바뀐다</span>
<span class="hljs-keyword">import</span> { jsx <span class="hljs-keyword">as</span> _jsx } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react/jsx-runtime&quot;</span>;

<span class="hljs-keyword">const</span> element = <span class="hljs-title function_">_jsx</span>(<span class="hljs-string">&quot;h1&quot;</span>, {
  <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;greeting&quot;</span>,
  <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span>,
});

<span class="hljs-comment">// 최종적으로 자바스크립트 객체를 생성한다</span>
<span class="hljs-keyword">const</span> element = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;h1&quot;</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;greeting&quot;</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span>,
  },
};
</code></pre>
<p>childeren을 인자로 건내주었던 createElement와 달리 jsx 함수는 children을 props로 전달하고 있다.</p>
<pre><code class="language-javascript hljs"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;h1&quot;</span>, { <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;greeting&quot;</span> }, <span class="hljs-string">&quot;Hello, world!&quot;</span>);

<span class="hljs-title function_">jsx</span>(<span class="hljs-string">&quot;h1&quot;</span>, { <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;greeting&quot;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span> });
</code></pre>
<p>리액트는 이렇게 변환된 객체를 읽어서 DOM으로 렌더링 한다.</p>
<p>미니 리액트를 만들 때는 트랜스파일러까지는 작업하지 않고 jsx 함수가 최종적으로 반환하는 JSX 객체의 구조만 만들어서 DOM으로 렌더링 시키려고 한다.</p>
<br />
<h1>JSX-Like 객체</h1>
<pre><code class="language-javascript hljs">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 태그 이름, 리액트 컴포넌트일 경우 대문자로 시작</span>
  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>; <span class="hljs-comment">// 전달 받은 값이 있을 경우 전달 받은 값으로 할당, 기본은 null</span>
  <span class="hljs-attr">ref</span>: <span class="hljs-literal">null</span>; <span class="hljs-comment">// 전달 받은 값이 있을 경우 전달 받은 값으로 할당, 기본은 null</span>
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">children</span>: []; <span class="hljs-comment">// 자식 노드 :: 문자열, 숫자, 빈 노드, 리액트 엘리먼트 등등</span>
  }
}
</code></pre>
<p>리액트 트랜스파일링과 jsx 함수에 대한 내용을 참고해서 JSX-Like 객체의 구조를 이렇게 같이 잡았다.<br>
이렇게 리액트의 내부 코드까지 살펴보면서 공부해본 적은 처음이라 정확히 이해가 전부 안 가는 부분들도 남아 있기는하다. 이해 안가면 계속 반복해서 보다보면 이해할 때가 있을 거라 생각하고 앞으로 계속 미니 리액트를 만들어가면서 더 이해가 깊어지지 않을까 생각한다.</p>
<br />
<br />
<h1>참고</h1>
<ul>
<li><a href="https://github.com/facebook/react/blob/main/packages/react/src/jsx/ReactJSXElement.js#L306">React github_jsxProd</a></li>
<li><a href="https://ko.react.dev/learn/writing-markup-with-jsx">JSX로 마크업 작성하기</a></li>
<li><a href="https://ko.react.dev/reference/react/createElement#createelement">createElement</a></li>
<li><a href="https://ko.legacy.reactjs.org/docs/introducing-jsx.html">JSX 소개</a></li>
<li><a href="https://velog.io/@hbsps/React-createElement%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%98%EA%B8%B0-%EA%B6%8C%EC%9E%A5-X">React createElement로 리팩토링 하기 (권장 X)</a></li>
<li><a href="https://velog.io/@sa02045/React-createElement-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0#createelement%EA%B0%80-legacy-api%EA%B0%80-%EB%90%9C-%EC%9D%B4%EC%9C%A0---%EB%AC%B8%EC%A0%9C%EC%A0%90">React - createElement 알아보기</a></li>
</ul>
4:["$","main",null,{"className":"ios-memo-container","children":["$","div",null,{"className":"post-container","children":[["$","div",null,{"className":"post-header","children":[["$","h1",null,{"className":"post-title","children":"미니 React 개발 Day2. JSX"}],["$","div",null,{"className":"post-info flex flex-row gap-[12px]","children":[["$","div",null,{"className":"post-author","children":"@sunny"}],["$","div",null,{"className":"post-date","children":"2025. 5. 20."}]]}],false]}],["$","div",null,{"className":"post-content","dangerouslySetInnerHTML":{"__html":"$12"}}]]}]}]
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
11:{"metadata":[["$","title","0",{"children":"Sunny Archive"}],["$","meta","1",{"name":"description","content":"익숙함을 향해 걸어가는 중"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]],"error":null,"digest":"$undefined"}
b:{"metadata":"$11:metadata","error":null,"digest":"$undefined"}
